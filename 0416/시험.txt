캡슐화 : 데이터 블럭들을 객체안에 넣어서 묶는다.
정보 은닉 : 멤버변수의 직접적인 접근 방지, 함수를통해서만 접근. 업그레이드 할 수 있음.
상속 : 상위클래스를 하위클래스가 그대로 사용할 수 있음

객체지향의 목표 : 코드의 재사용

#include/주석/cin, cout (화살표 방향 주의), endl = \n/

동적메모리 : malloc -> free / new -> delete (메모리 누수)
ㄴ free [] arr;

객체 : 상태와 동작을 가지고잇음, 클래스
장점 : 신뢰성, 재사용, 업그레이드, 디버깅쉬움

객체의 동적 생성(Car *a = new Car()), 정적 생성 Car a();

접근 제어(public, private, protected)

접근자 : getSpeed(), 설정자 : setSpeed(a)
UML : class_uml.png 참조


생성자 (디폴트 생성자가 있음)
소멸자 (중복정의 x, arg 없음)

오버로딩(함수의 중복정의) : arg, 함수명 똑같아야함

오버라이딩(변수의 중복정의) : 변수명 똑같아야함


멤버 변수 초기화 방법 :

- Car(int s = 10, int g = 5, string c = "a") {}
- Car(int s, int g, string c) : speed(s), gear(g), color(c) {} <- 상수 초기화 가능

상속 
- 장점 : 재사용 , 기존클래스를 일부만 재정의
- 상하적인 상속관계여야 함.
- 생성자는 부모먼저, 소멸자는 하위생성자먼저(스택관계)
- 부모 생성자를 명시적으로 호출 가능 (없으면 기본생성자 호출)
Rectangle(int x, int y, int w = 0, int h=0) : Shape(x, y) {} <- x, y가 Shape의 해당 생성자를 호출
